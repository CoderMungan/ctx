//   /    Context:                     https://ctx.ist
// ,'`./    do you remember?
// `.,'\
//   \    Copyright 2025-present Context contributors.
//                 SPDX-License-Identifier: Apache-2.0

package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
)

var (
	loopPromptFile    string
	loopTool          string
	loopMaxIterations int
	loopCompletionMsg string
	loopOutputFile    string
)

// LoopCmd returns the loop command.
func LoopCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "loop",
		Short: "Generate a Ralph loop script",
		Long: `Generate a ready-to-use shell script for running a Ralph loop.

A Ralph loop continuously runs an AI assistant with the same prompt until
a completion signal is detected. This enables iterative development where
the AI can build on its previous work.

Examples:
  ctx loop                           # Generate loop.sh for Claude
  ctx loop --tool aider              # Generate for Aider
  ctx loop --prompt TASKS.md         # Use custom prompt file
  ctx loop --max-iterations 10       # Limit to 10 iterations
  ctx loop -o my-loop.sh             # Output to custom file`,
		RunE: runLoop,
	}

	cmd.Flags().StringVarP(&loopPromptFile, "prompt", "p", "PROMPT.md", "Prompt file to use")
	cmd.Flags().StringVarP(&loopTool, "tool", "t", "claude", "AI tool: claude, aider, or generic")
	cmd.Flags().IntVarP(&loopMaxIterations, "max-iterations", "n", 0, "Maximum iterations (0 = unlimited)")
	cmd.Flags().StringVarP(&loopCompletionMsg, "completion", "c", "SYSTEM_CONVERGED", "Completion signal to detect")
	cmd.Flags().StringVarP(&loopOutputFile, "output", "o", "loop.sh", "Output script filename")

	return cmd
}

func runLoop(cmd *cobra.Command, args []string) error {
	green := color.New(color.FgGreen).SprintFunc()

	// Validate tool
	validTools := map[string]bool{"claude": true, "aider": true, "generic": true}
	if !validTools[loopTool] {
		return fmt.Errorf("invalid tool %q: must be claude, aider, or generic", loopTool)
	}

	// Generate the script
	script := generateLoopScript(loopPromptFile, loopTool, loopMaxIterations, loopCompletionMsg)

	// Write to file
	if err := os.WriteFile(loopOutputFile, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to write %s: %w", loopOutputFile, err)
	}

	fmt.Printf("%s Generated %s\n", green("âœ“"), loopOutputFile)
	fmt.Println()
	fmt.Println("To start the loop:")
	fmt.Printf("  ./%s\n", loopOutputFile)
	fmt.Println()
	fmt.Printf("Tool: %s\n", loopTool)
	fmt.Printf("Prompt: %s\n", loopPromptFile)
	if loopMaxIterations > 0 {
		fmt.Printf("Max iterations: %d\n", loopMaxIterations)
	} else {
		fmt.Println("Max iterations: unlimited")
	}
	fmt.Printf("Completion signal: %s\n", loopCompletionMsg)

	return nil
}

func generateLoopScript(promptFile, tool string, maxIterations int, completionMsg string) string {
	// Get absolute path for prompt file
	absPrompt, _ := filepath.Abs(promptFile)

	var aiCommand string
	switch tool {
	case "claude":
		aiCommand = fmt.Sprintf(`claude --print "$(cat %s)"`, absPrompt)
	case "aider":
		aiCommand = fmt.Sprintf(`aider --message-file %s`, absPrompt)
	case "generic":
		aiCommand = fmt.Sprintf(`# Replace with your AI CLI command
    cat %s | your-ai-cli`, absPrompt)
	}

	maxIterCheck := ""
	if maxIterations > 0 {
		maxIterCheck = fmt.Sprintf(`
    # Check iteration limit
    if [ $ITERATION -ge %d ]; then
        echo "Reached maximum iterations (%d)"
        break
    fi`, maxIterations, maxIterations)
	}

	script := fmt.Sprintf(`#!/bin/bash
#
# Ralph Loop Script
# Generated by: ctx loop
#
# This script runs an AI assistant in a loop until completion.
# The AI works on the same prompt file repeatedly, building on
# previous work visible in files and git history.
#

set -e

PROMPT_FILE="%s"
COMPLETION_SIGNAL="%s"
ITERATION=0

echo "Starting Ralph Loop"
echo "==================="
echo "Prompt: $PROMPT_FILE"
echo "Completion signal: $COMPLETION_SIGNAL"
echo ""

# Ensure prompt file exists
if [ ! -f "$PROMPT_FILE" ]; then
    echo "Error: Prompt file not found: $PROMPT_FILE"
    exit 1
fi

while true; do
    ITERATION=$((ITERATION + 1))
    echo ""
    echo "=== Iteration $ITERATION ==="
    echo ""
%s
    # Run the AI tool
    OUTPUT=$(%s 2>&1) || true

    echo "$OUTPUT"

    # Check for completion signal
    if echo "$OUTPUT" | grep -q "$COMPLETION_SIGNAL"; then
        echo ""
        echo "=== Loop Complete ==="
        echo "Detected completion signal: $COMPLETION_SIGNAL"
        echo "Total iterations: $ITERATION"
        break
    fi

    # Small delay to prevent runaway loops
    sleep 1
done
`, absPrompt, completionMsg, maxIterCheck, aiCommand)

	return script
}
